diff --git a/node_modules/@2colors/esphome-native-api/lib/connection.js b/node_modules/@2colors/esphome-native-api/lib/connection.js
index 7c2ef1b..cd1b031 100644
--- a/node_modules/@2colors/esphome-native-api/lib/connection.js
+++ b/node_modules/@2colors/esphome-native-api/lib/connection.js
@@ -6,6 +6,11 @@ const Package = require('../package.json');
 const PlaintextFrameHelper = require('./utils/plaintextFrameHelper');
 const NoiseFrameHelper = require('./utils/noiseFrameHelper');
 
+// ESPHome API version to advertise in HelloRequest.
+// ESPHome 2026.1.x currently uses API v1.14.
+const API_VERSION_MAJOR = 1;
+const API_VERSION_MINOR = 14;
+
 class EsphomeNativeApiConnection extends EventEmitter {
     constructor({
         port = 6053,
@@ -36,6 +41,11 @@ class EsphomeNativeApiConnection extends EventEmitter {
             this.emit('message', type, mapped);
         });
 
+        // Surface unknown/new message ids (non-fatal) so callers can diagnose protocol drift.
+        this.frameHelper.on('unknownMessage', (id) => {
+            this.emit('unknownMessage', id);
+        });
+
         // frame helper close
         this.frameHelper.on('close', () => {
             this.connected = false;
@@ -57,8 +67,22 @@ class EsphomeNativeApiConnection extends EventEmitter {
                 const helloResponse = await this.helloService(this.clientInfo);
                 this.supportsRawBLEAdvertisements = helloResponse.apiVersionMajor > 1 ||
                     (helloResponse.apiVersionMajor === 1 && helloResponse.apiVersionMinor >= 9);
-                const { invalidPassword } =  await this.connectService(this.password);
-                if (invalidPassword === true) throw new Error(`Invalid password`);
+                /**
+                 * ESPHome 2026.1.0 removed password authentication messages entirely.
+                 *
+                 * Old clients used "ConnectRequest/ConnectResponse" (same IDs/wire format as the
+                 * later "AuthenticationRequest/AuthenticationResponse"). With modern ESPHome this
+                 * request will never be answered, causing clients to hang waiting for ConnectResponse.
+                 *
+                 * - If Noise encryption is configured (preferred), the Noise handshake authenticates
+                 *   the connection and no password exchange is required.
+                 * - If plaintext + password is configured, attempt the legacy password exchange.
+                 * - If plaintext and no password, treat HelloResponse as authorized.
+                 */
+                if (!this.encryptionKey && this.password) {
+                    const { invalidPassword } = await this.connectService(this.password);
+                    if (invalidPassword === true) throw new Error(`Invalid password`);
+                }
                 this.authorized = true;
             } catch(e) {
                 this.emit('error', e);
@@ -208,6 +232,10 @@ class EsphomeNativeApiConnection extends EventEmitter {
         const message = new pb.HelloRequest();
 
         if (clientInfo !== undefined) message.setClientInfo(clientInfo);
+        // Advertise the API version this client supports so the server can negotiate compatibility.
+        // Without this, api_version defaults to 0.0 which newer ESPHome versions can reject.
+        message.setApiVersionMajor(API_VERSION_MAJOR);
+        message.setApiVersionMinor(API_VERSION_MINOR);
 
         return await this.sendMessageAwaitResponse(message, 'HelloResponse');
     }
@@ -285,6 +313,11 @@ class EsphomeNativeApiConnection extends EventEmitter {
         message.setDumpConfig(dumpConfig);
         this.sendMessage(message);
     }
+    subscribeBluetoothConnectionsFreeService() {
+        if (!this.connected) throw new Error(`Not connected`);
+        if (!this.authorized) throw new Error(`Not authorized`);
+        this.sendMessage(new pb.SubscribeBluetoothConnectionsFreeRequest());
+    }
     cameraImageService(single = true, stream = false) {
         if (!this.connected) throw new Error(`Not connected`);
         if (!this.authorized) throw new Error(`Not authorized`);
@@ -341,7 +374,32 @@ class EsphomeNativeApiConnection extends EventEmitter {
     async connectBluetoothDeviceService(address, addressType) {
         if (!this.connected) throw new Error(`Not connected`);
         if (!this.authorized) throw new Error(`Not authorized`);
-        const message = new pb.BluetoothDeviceRequest([address]);
+        /**
+         * ESPHome 2026+ BLE proxy (project memory):
+         * The legacy CONNECT (request_type=0) is deprecated. Newer firmwares expect the V3 connect
+         * variants (with/without cache) to properly handle address type + connection caching.
+         *
+         * Use CONNECT_V3_WITH_CACHE as the default for better stability.
+         */
+        const message = new pb.BluetoothDeviceRequest();
+        message.setAddress(address);
+        message.setRequestType(pb.BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE);
+        if(addressType != undefined) {
+            message.setHasAddressType(true);
+            message.setAddressType(addressType);
+        }
+        return await this.sendMessageAwaitResponse(
+            message,
+            'BluetoothDeviceConnectionResponse',
+            10
+        );
+    }
+    async connectBluetoothDeviceServiceWithoutCache(address, addressType) {
+        if (!this.connected) throw new Error(`Not connected`);
+        if (!this.authorized) throw new Error(`Not authorized`);
+        const message = new pb.BluetoothDeviceRequest();
+        message.setAddress(address);
+        message.setRequestType(pb.BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE);
         if(addressType != undefined) {
             message.setHasAddressType(true);
             message.setAddressType(addressType);
@@ -352,6 +410,18 @@ class EsphomeNativeApiConnection extends EventEmitter {
             10
         );
     }
+    async clearBluetoothDeviceCacheService(address) {
+        if (!this.connected) throw new Error(`Not connected`);
+        if (!this.authorized) throw new Error(`Not authorized`);
+        const message = new pb.BluetoothDeviceRequest();
+        message.setAddress(address);
+        message.setRequestType(pb.BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE);
+        return await this.sendMessageAwaitResponse(
+            message,
+            'BluetoothDeviceClearCacheResponse',
+            10
+        );
+    }
     async disconnectBluetoothDeviceService(address) {
         if (!this.connected) throw new Error(`Not connected`);
         if (!this.authorized) throw new Error(`Not authorized`);
@@ -396,23 +466,43 @@ class EsphomeNativeApiConnection extends EventEmitter {
         const message = new pb.BluetoothGATTGetServicesRequest([address]);
 
         const servicesList = [];
+        let gattError = null;
         const onMessage = (message) => {
             if (message.address === address)
                 servicesList.push(...message.servicesList);
         };
+        const onError = (message) => {
+            if (message.address !== address) return;
+            // Some firmwares emit GATTErrorResponse and still send a DoneResponse.
+            // Capture it so callers don't proceed with an empty/invalid services list.
+            gattError = message;
+        };
         this.on('message.BluetoothGATTGetServicesResponse', onMessage);
+        this.on('message.BluetoothGATTErrorResponse', onError);
         await this.sendMessageAwaitResponse(
             message,
-            'BluetoothGATTGetServicesDoneResponse'
+            'BluetoothGATTGetServicesDoneResponse',
+            // Project memory:
+            // ESPHome BLE proxy service discovery commonly takes >5s, especially on first connect
+            // or when the proxy has to rebuild its internal cache. The default 5s timeout causes
+            // spurious failures like "Timeout getting services..." and then cascades into add-on
+            // restarts/retries. Use a larger, still-bounded timeout.
+            20
         ).then(
             () => {
                 this.off('message.BluetoothGATTGetServicesResponse', onMessage);
+                this.off('message.BluetoothGATTErrorResponse', onError);
             },
             (e) => {
                 this.off('message.BluetoothGATTGetServicesResponse', onMessage);
+                this.off('message.BluetoothGATTErrorResponse', onError);
                 throw e;
             }
         );
+        if (gattError) {
+            const { handle, error } = gattError;
+            throw new Error(`BluetoothGATTErrorResponse address=${address} handle=${handle} error=${error}`);
+        }
         return { address, servicesList };
     }
 
diff --git a/node_modules/@2colors/esphome-native-api/lib/utils/frameHelper.js b/node_modules/@2colors/esphome-native-api/lib/utils/frameHelper.js
index f9c2baf..dcbb2e6 100644
--- a/node_modules/@2colors/esphome-native-api/lib/utils/frameHelper.js
+++ b/node_modules/@2colors/esphome-native-api/lib/utils/frameHelper.js
@@ -34,10 +34,15 @@ class FrameHelper extends EventEmitter {
     }
 
     buildMessage(messageId, bytes) {
+        // ESPHome API evolves over time; newer firmwares may emit message IDs this client
+        // doesn't understand yet. Do not treat that as a fatal socket error â€” callers will
+        // safely skip unknown frames so the connection stays healthy.
+        const type = id_to_type[messageId];
+        if (!type || !pb[type]) return undefined;
         try {
-            return pb[id_to_type[messageId]].deserializeBinary(bytes);
-        } catch(e) {
-            this.emit('error', new Error(`Failed find message type for Id: ${messageId}`));
+            return pb[type].deserializeBinary(bytes);
+        } catch (e) {
+            return undefined;
         }
     }
 }
diff --git a/node_modules/@2colors/esphome-native-api/lib/utils/messages.js b/node_modules/@2colors/esphome-native-api/lib/utils/messages.js
index 734c0fc..2aca3f6 100644
--- a/node_modules/@2colors/esphome-native-api/lib/utils/messages.js
+++ b/node_modules/@2colors/esphome-native-api/lib/utils/messages.js
@@ -91,6 +91,9 @@ const id_to_type =
     87: 'UnsubscribeBluetoothLEAdvertisementsRequest',
     88: 'BluetoothDeviceClearCacheResponse',
     93: 'BluetoothLERawAdvertisementsResponse',
+    // ESPHome 2026+ appears to emit raw BLE advertisements using a newer message id.
+    // Keep the legacy id (93) for backward compatibility, and also accept 126.
+    126: 'BluetoothLERawAdvertisementsResponse',
     97: 'ListEntitiesTextResponse',
     98: 'TextStateResponse',
     99: 'TextCommandRequest'
diff --git a/node_modules/@2colors/esphome-native-api/lib/utils/noiseFrameHelper.js b/node_modules/@2colors/esphome-native-api/lib/utils/noiseFrameHelper.js
index a07678d..0135de5 100644
--- a/node_modules/@2colors/esphome-native-api/lib/utils/noiseFrameHelper.js
+++ b/node_modules/@2colors/esphome-native-api/lib/utils/noiseFrameHelper.js
@@ -67,6 +67,14 @@ class NoiseFrameHelper extends FrameHelper {
                         const message = this.deserialize(
                             this.decryptor.DecryptWithAd([], frame)
                         );
+                        if (message && message.__unknownMessageId != null) {
+                            this.emit("unknownMessage", {
+                                id: message.__unknownMessageId,
+                                length: message.length,
+                                bytes: message.__unknownBytes || ""
+                            });
+                            continue;
+                        }
                         this.emit("message", message);
                 }
             }
@@ -127,7 +135,17 @@ class NoiseFrameHelper extends FrameHelper {
         if (buffer.length < 4) return null;
         const messageId = (buffer[0] << 8) | buffer[1];
         const messageLength = (buffer[2] << 8) | buffer[3];
-        const message = this.buildMessage(messageId, buffer.subarray(4, messageLength + 4));
+        const raw = buffer.subarray(4, messageLength + 4);
+        const message = this.buildMessage(messageId, raw);
+        // Unknown/unhandled message IDs must be skipped safely (do not crash the stream parser).
+        if (!message) {
+            return {
+                __unknownMessageId: messageId,
+                // NOTE: on encrypted links, `raw` may be a Uint8Array; wrap so we get real hex, not "8,2,16,..."
+                __unknownBytes: Buffer.from(raw.subarray(0, 16)).toString('hex'),
+                length: messageLength + 4,
+            };
+        }
         message.length = messageLength + 4;
         return message;
     }
diff --git a/node_modules/@2colors/esphome-native-api/lib/utils/plaintextFrameHelper.js b/node_modules/@2colors/esphome-native-api/lib/utils/plaintextFrameHelper.js
index 8bb8dfe..c5770d5 100644
--- a/node_modules/@2colors/esphome-native-api/lib/utils/plaintextFrameHelper.js
+++ b/node_modules/@2colors/esphome-native-api/lib/utils/plaintextFrameHelper.js
@@ -42,7 +42,16 @@ class PlaintextFrameHelper extends FrameHelper {
         if (messageLength + offset > buffer.length)
             return null;
 
-        const message = this.buildMessage(messageId, buffer.subarray(offset, messageLength + offset));
+        const raw = buffer.subarray(offset, messageLength + offset);
+        const message = this.buildMessage(messageId, raw);
+        // Unknown/unhandled message IDs must be skipped safely (do not crash the stream parser).
+        if (!message) {
+            return {
+                __unknownMessageId: messageId,
+                __unknownBytes: Buffer.from(raw.subarray(0, 16)).toString('hex'),
+                length: messageLength + offset,
+            };
+        }
         message.length = messageLength + offset;
         return message;
     }
@@ -54,6 +63,14 @@ class PlaintextFrameHelper extends FrameHelper {
         try {
             while ((message = this.deserialize(this.buffer))) {
                 this.buffer = this.buffer.slice(message.length);
+                if (message.__unknownMessageId != null) {
+                    this.emit("unknownMessage", {
+                        id: message.__unknownMessageId,
+                        length: message.length,
+                        bytes: message.__unknownBytes || ""
+                    });
+                    continue;
+                }
                 this.emit("message", message);
             }
         } catch (e) {
