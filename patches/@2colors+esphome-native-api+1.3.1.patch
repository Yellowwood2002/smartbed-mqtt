diff --git a/node_modules/@2colors/esphome-native-api/lib/connection.js b/node_modules/@2colors/esphome-native-api/lib/connection.js
index 7c2ef1b..78bf6b5 100644
--- a/node_modules/@2colors/esphome-native-api/lib/connection.js
+++ b/node_modules/@2colors/esphome-native-api/lib/connection.js
@@ -6,6 +6,11 @@ const Package = require('../package.json');
 const PlaintextFrameHelper = require('./utils/plaintextFrameHelper');
 const NoiseFrameHelper = require('./utils/noiseFrameHelper');
 
+// ESPHome API version to advertise in HelloRequest.
+// ESPHome 2026.1.x currently uses API v1.14.
+const API_VERSION_MAJOR = 1;
+const API_VERSION_MINOR = 14;
+
 class EsphomeNativeApiConnection extends EventEmitter {
     constructor({
         port = 6053,
@@ -57,8 +62,22 @@ class EsphomeNativeApiConnection extends EventEmitter {
                 const helloResponse = await this.helloService(this.clientInfo);
                 this.supportsRawBLEAdvertisements = helloResponse.apiVersionMajor > 1 ||
                     (helloResponse.apiVersionMajor === 1 && helloResponse.apiVersionMinor >= 9);
-                const { invalidPassword } =  await this.connectService(this.password);
-                if (invalidPassword === true) throw new Error(`Invalid password`);
+                /**
+                 * ESPHome 2026.1.0 removed password authentication messages entirely.
+                 *
+                 * Old clients used "ConnectRequest/ConnectResponse" (same IDs/wire format as the
+                 * later "AuthenticationRequest/AuthenticationResponse"). With modern ESPHome this
+                 * request will never be answered, causing clients to hang waiting for ConnectResponse.
+                 *
+                 * - If Noise encryption is configured (preferred), the Noise handshake authenticates
+                 *   the connection and no password exchange is required.
+                 * - If plaintext + password is configured, attempt the legacy password exchange.
+                 * - If plaintext and no password, treat HelloResponse as authorized.
+                 */
+                if (!this.encryptionKey && this.password) {
+                    const { invalidPassword } = await this.connectService(this.password);
+                    if (invalidPassword === true) throw new Error(`Invalid password`);
+                }
                 this.authorized = true;
             } catch(e) {
                 this.emit('error', e);
@@ -208,6 +227,10 @@ class EsphomeNativeApiConnection extends EventEmitter {
         const message = new pb.HelloRequest();
 
         if (clientInfo !== undefined) message.setClientInfo(clientInfo);
+        // Advertise the API version this client supports so the server can negotiate compatibility.
+        // Without this, api_version defaults to 0.0 which newer ESPHome versions can reject.
+        message.setApiVersionMajor(API_VERSION_MAJOR);
+        message.setApiVersionMinor(API_VERSION_MINOR);
 
         return await this.sendMessageAwaitResponse(message, 'HelloResponse');
     }
@@ -341,7 +364,16 @@ class EsphomeNativeApiConnection extends EventEmitter {
     async connectBluetoothDeviceService(address, addressType) {
         if (!this.connected) throw new Error(`Not connected`);
         if (!this.authorized) throw new Error(`Not authorized`);
-        const message = new pb.BluetoothDeviceRequest([address]);
+        /**
+         * ESPHome 2026+ BLE proxy (project memory):
+         * The legacy CONNECT (request_type=0) is deprecated. Newer firmwares expect the V3 connect
+         * variants (with/without cache) to properly handle address type + connection caching.
+         *
+         * Use CONNECT_V3_WITH_CACHE as the default for better stability.
+         */
+        const message = new pb.BluetoothDeviceRequest();
+        message.setAddress(address);
+        message.setRequestType(pb.BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE);
         if(addressType != undefined) {
             message.setHasAddressType(true);
             message.setAddressType(addressType);
@@ -352,6 +384,34 @@ class EsphomeNativeApiConnection extends EventEmitter {
             10
         );
     }
+    async connectBluetoothDeviceServiceWithoutCache(address, addressType) {
+        if (!this.connected) throw new Error(`Not connected`);
+        if (!this.authorized) throw new Error(`Not authorized`);
+        const message = new pb.BluetoothDeviceRequest();
+        message.setAddress(address);
+        message.setRequestType(pb.BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE);
+        if(addressType != undefined) {
+            message.setHasAddressType(true);
+            message.setAddressType(addressType);
+        }
+        return await this.sendMessageAwaitResponse(
+            message,
+            'BluetoothDeviceConnectionResponse',
+            10
+        );
+    }
+    async clearBluetoothDeviceCacheService(address) {
+        if (!this.connected) throw new Error(`Not connected`);
+        if (!this.authorized) throw new Error(`Not authorized`);
+        const message = new pb.BluetoothDeviceRequest();
+        message.setAddress(address);
+        message.setRequestType(pb.BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE);
+        return await this.sendMessageAwaitResponse(
+            message,
+            'BluetoothDeviceClearCacheResponse',
+            10
+        );
+    }
     async disconnectBluetoothDeviceService(address) {
         if (!this.connected) throw new Error(`Not connected`);
         if (!this.authorized) throw new Error(`Not authorized`);
@@ -403,7 +463,13 @@ class EsphomeNativeApiConnection extends EventEmitter {
         this.on('message.BluetoothGATTGetServicesResponse', onMessage);
         await this.sendMessageAwaitResponse(
             message,
-            'BluetoothGATTGetServicesDoneResponse'
+            'BluetoothGATTGetServicesDoneResponse',
+            // Project memory:
+            // ESPHome BLE proxy service discovery commonly takes >5s, especially on first connect
+            // or when the proxy has to rebuild its internal cache. The default 5s timeout causes
+            // spurious failures like "Timeout getting services..." and then cascades into add-on
+            // restarts/retries. Use a larger, still-bounded timeout.
+            20
         ).then(
             () => {
                 this.off('message.BluetoothGATTGetServicesResponse', onMessage);
